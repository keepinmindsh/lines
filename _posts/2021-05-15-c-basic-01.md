---
title:  "C의 기본 문법"
excerpt: "기본 문법"

categories:
  - C
tags:
  - C
classes: wide
last_modified_at: 2019-05-15T21:00:00-05:00
---

> 처음의 마음을 절대 잊지 말 것. 초심불망

***

# 진법 변환 

![](https://keepinmindsh.github.io/lines/assets/img/C001-1.jpeg){: .align-center} 


***

![](https://keepinmindsh.github.io/lines/assets/img/C001-2.jpeg){: .align-center} 


# C 기초 문법 

### 자료형

char  
short  
int  
long  
long long  
float  
double  
long double  
signed  
unsigned  

### 연산자 

**대입 연산자**  
= : 치환

**산술 연산자**  
+, -, *, /, &, ++, -- : 사칙 연산  

**관계 연산자**  
<, >, <=, >=, ++, != : 논리합, 논리곱, 논리부정
두 식의 대소 크기를 비교하는 연산자로서 연산 결과가 참이나 거짓으로 표현한다.
C 언어에서 참(true)은 0이 아닌 모든 수를 의미하며, 거짓(false)은 0을 의미한다.  

**논리 연산자**  
&&, ||, ! : 대소 및 항등 판정

**할당 연산자**  
+=, -=, *=, /=, %=, ...  

**삼항 연산자**  
? : 조건 판정

**단항 연산자**  
++ : 1씩 증가  
-- : 1씩 감소  
+, -  

**비트 연산자**  
&, |, ~, ^, <<, >>  
연산자 우선순위는 고려되어야 하나, 괄호 등을 효율적으로 사용하면 연산자 우선순위를 모른다고 해서 크게 문제될 부분은 없습니다.  

**포인터 연산자**  
& : 메모리의 주소를 구한다.  
* : 포인터 변수가 갖는 주소에 저장된 값을 구한다.  

# 메모리와 포인터 

**변수** : 변수의 본질은 메모리이며 모든 메모리는 자신의 위치를 식별하기 위한 근거로 고유번호(일련번호)를 같는데, 이 번호를 메모리의 주소라고 합니다.  

![](https://keepinmindsh.github.io/lines/assets/img/C001.jpeg){: .align-center} 

- 이름에 부여된 메모리
- 그 안에 담긴 정보
- 메모리의 주소

```java

#include <stdio.h>                              

int main(void) {
  // 임의 변경 가능한 메모리 주소의 특정 위치에 nData가 "지정"된다.
  int nData = 10;
  printf("%s\n", "nData");

  // 변수 nData에 들어잇는 값을 출력 
  printf("%d\n", "nData");

  // 변수 nData의 메모리 주소를 출력 
  printf("%p\n", &nData); // 0012FF28
  return 0;
}

```

### 위의 코드 프로세스를 아래의 이미지와 같이 주소값으로 조정

![](https://keepinmindsh.github.io/lines/assets/img/C002.jpeg){: .align-center} 

```java

#include <stdio.h>

void main() {

  int nData = 300;
  return 0;
}

```

비주얼 스튜디오에서 메모리창으로 봤을 때,


![](https://keepinmindsh.github.io/lines/assets/img/C009.jpeg){: .align-center} 

**메모리의 종류**

- Stack
자동변수이고 지역변수인 변수가 사용하는 메모리 영역이며, 임시 메모리의 성격을 가진다. 크기가 작고(기본 설정을 기준으로 최대 1MB 수준) 관리(할당 및 반환)가 자동으로 이루어지는 장점이 있다.
- Heap
동적 할당 할 수 있는 자유 메모리 영역이며, 개발자 자신 스스로 직접관리(수동)해야 한다. 32비트 응용 프로그램의 경우, 대략 1xGB 정도를 사용할 수 있다.
따라서 대량의 메모리가 필요하거나 필요한 메모리의 크리를 미리 알 수 없을 때 사용한다.
- PE Image
  - Text section
C 언어의 소스코드가 번역된 기계어가 저장된 메모리 영역이며, 기본적으로 읽기 전용 메모리이다. 만일 어떤 식으로 이 영역의 메모리를 변조한다면, 해킹이라 할 수 있다.
  - Read Only
상수 형태로 기술하는 문자열이 저장된 메모리 영역이며, Text 영역처럼 읽기는 가능하나 쓰기는 허용되지 않는다.
  - Read/Write
정적 변수나 전역 변수들이 사용하는 메모리 영역이며, 별도로 초기화하지 않아도 0으로 초기화된다. 관리는 자동이라서 힙 영역 메모리처럼 할당 및 해제를 신경 쓸 필요는 없다.