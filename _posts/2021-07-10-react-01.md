---
title: "React JS"
excerpt: "SPA 개발 및 CBD 기반의 개발을 위한 웹 프레인워크"

categories:
  - Script
tags:
  - Script 
classes: wide
last_modified_at: 2021-06-29T22:49:00-05:00
---

> 다스림의 표준 - 저절로 다스려지게 하라.   

***

# props 와 state를 나누어 사용하도록 한 이유 

먼저 개발자들에게 명확한 관념 모델(static mental model)을 제공합니다.
관념 모델은 무엇이 어떻게 동작하는지 이해할 때 진행되는 일련의 사고 프로세스를 의미합니다.
즉, 논리적으로 이치에 맞는 사고 모델을 제공한다는 것이다.

# create-react-app 를 이용하여 react-project 생성하기 

```

# create-react-app 을 이용한 작업 환경 구성하기
# npm {명령어} -{옵션} {Package}         
# install Package 설치하기 
# -g 전역에 설치하기                    
> npm install -g create-react-app


> create-react-app hello-world 

> cd hello-world

> npm start 

```

# create-react-app 을 이용하지 않고 빌드없이 바로 이용하기 

```html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
    <div id="root"></div>
    <script src="https://unpkg.com/react@15/dist/react.js"></script>
    <script src="https://unpkg.com/react-dom@15/dist/react-dom.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.js"></script>
    <script src="./js/app.js" type="text/babel"></script> 
</body>
</html>

```

```javascript

// js/app.js 
ReactDOM.render(
  <h1>Hello, world!</h1>,
  document.getElementById('root')
);

```

# React Renering Process 

### ReactDOM의 역할
React.js는 자바스크립트 내에 DOM Tree와 같은 구조체를 VIRTUAL DOM으로 갖고 있습니다. 다시 그릴 때는 그 구조체의 전후 상태를 비교하여 변경이 필요한 최소한의 요소만 실제 DOM에 반영합니다. 따라서 무작위로 다시 그려도 변경에 필요한 최소한의 DOM만 갱신되기 때문에 빠르게 처리할 수 있습니다.  

![](https://keepinmindsh.github.io/lines/assets/img/reactRendering.png){: .align-center}

Virtual DOM 은 DOM 차원에서의 더블 버퍼링이랑 다름이 없다.  
변화가 일어나면 그것을 오프라인 DOM 트리에 적용시키는데,  
이 DOM 트리는 렌더링도 되지 않기때문에 연산 비용이 적다.  
연산이 끝나고나면 그 최종적인 변화를 실제 DOM 에 던져주는 것이다.  
그러면, 레이아웃 계산과 리렌더링의 규모는 커지겠지만, 딱 한번만 연산이 일어나게 된다.  
바로 이렇게, 하나로 묶어서 적용시키는것이, 연산의 횟수를 줄일 수 있는 방법이다.   


React가 DOM보다 빠른 것이 아니라, 유지보수 가능한 어플리케이션을 만드는 것을 도와주고 대부분의 경우에 '충분히 빠르다.'  
실제로 최적화 작업을 직접 했을 때가 React를 사용했을 때 보다 빠르지만 이를 자동화하여 처리해주는 React가 유지보수 및 생산성을 고려하였을 때 배가 되는 것  
React 를 사용한다고 해도 최적화 작업이 제대로 이뤄지지 않으면 오히려 속도가 더 느릴수도 있다.  


# Props


# State 



# JSX 

JSX : Javascript + XML 을 합쳐서 JSX라고 말한다.  

```javascript 

const element = <h1>Hello, world!</h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);

```

위의 코드에서 볼 수 있듯이 마치 html 의 요소를 정의한 것처럼 보이지만 이는 모두 JSX에 선언된 요소들이라고 보는게 옳다.  

```javascript 

function getHelloWorldByYourName(user){
  return user.myName;
};

const user = {
    myName : "홍길동"
};

const element = (
  <h1><strong>My Name is {getHelloWorldByYourName(user)}</strong></h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);

```

### JSX에서의 표현식

```javascript 

const name = 'Jeong Seung Hwa';
const element = <h1>Hello, {name}</h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);

```

### JSX에서의 요소 바인딩

```javascript 

function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Jeong',
  lastName: 'Seung Hwa'
};

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);

```

### 속성에 대한 정의

```javascript

// 따옴표를 이용햇 문자열 리터럴을 정의할 수 있습니다. 
const element = <div tabIndex="0"></div>;

// 중괄호를 사용하여 어트리뷰트에 JavaScript 표현식을 삽입할 수도 있습니다. 
const element = <img src={user.avatarUrl}></img>;

```

### JSX로의 자식 정의

```javascript

// tag 안의 자식 요소를 포함할 수 있습니다. 
const element = (
  <div>
    <h1>Hello!</h1>
    <h2>Good to see you here.</h2>
  </div>
);      


```

- JSX는 주입 공격을 방지합니다.
- 기본적으로 React DOM은 JSX에 삽입된 모든 값을 렌더링 하기 전에 이스케이프하므로, 애플리케이션에서 명시적으로 작성되지 않은 내용은 주입되지 않습니다. 모든 항목은 렌더링 되기 전에 문자열로 변환됩니다.
- JSX는 객체를 표현합니다.

```javascript 

// 아래의 두개의 코드는 모두 createElment를 호출하는 방식이지만 표현식이 다릅니다. 
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);

```

### JSX 속성 요소

```javascript 

accept acceptCharset accessKey action allowFullScreen allowTransparency alt
async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
charSet checked classID className colSpan cols content contentEditable
contextMenu controls coords crossOrigin data dateTime default defer dir
disabled download draggable encType form formAction formEncType formMethod
formNoValidate formTarget frameBorder headers height hidden high href hrefLang
htmlFor httpEquiv icon id inputMode integrity is keyParams keyType kind label
lang list loop low manifest marginHeight marginWidth max maxLength media
mediaGroup method min minLength multiple muted name noValidate nonce open
optimum pattern placeholder poster preload radioGroup readOnly rel required
reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
summary tabIndex target title type useMap value width wmode wrap


```

# Element

```javascript

const element = <h1> Hello, World </h1>;
// 브라우저의 DOM 엘리먼트와 달리 React 엘리먼트는 일반 객체이며 쉽게 생성할 수 있습니다. 
// React DOM 은 React 엘리먼트와 일치하도록 DOM을 업데이트합니다. 

```

### DOM에 엘리먼트 렌더링하기

```javascript

// 이 안에 들어가는 모든 엘리먼트를 React DOM에서 관리하기 때문에 이것을 "루트(root)" DOM 노드라고 부릅니다. 
<div id="root" > <div>

// React 엘리먼트를 Root 엘리먼트에 로딩하려면 아래와 같이 사용합니다. 
const element = <h1>Hello, world</h1>;
ReactDOM.render(element, document.getElementById('root'));

```

### 렌더링 된 엘리먼트 업데이트 하기

```javascript

// ReactDOM 의 render에 의해서 UI 요소를 갱신하는 방식                             
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}

setInterval(tick, 1000);

```

### Components 

컴포넌트 기반 소프트웨어 공학 ( Component-based software engineering)  

CBD는 개발 방법론의 핵심이 되는 '재사용성','생산성' 등을 향상시키며 요구사항이 수시로 바뀌는 현대의 서비스 개발에 특화되어 빠르게 서비스를 피벗하거나 사용자가 급등할 수 있는 환경을 고려해 유연한 환경을 조성하는데 도움이 됩니다.  

#### Uncontrolled Components

Uncontrolled Component는 상태를 직접 제어하지 않습니다. 

```javascript 

const Hello = () => <div>Hello</div>

const Hi = () =>  <div>Hi</div>

```

#### Controlled component

상태를 직접제어하는 컴포넌트 입니다.   

```javascript 

const HelloWorld = () => {
  const [value, setValue] = userState(0)

  return (
    <HelloComponent handleClick={setValue} >
      { value ? <Hello /> : <Hi /> }
    </HelloComponent>
  )
}                               

```

#### Pure component

Pure Component는 리액트를 이용한 컴포넌트 기본 개발 방법에서 가장 기본적인 컴포넌트입니다.   
Pure Component와 Component는 매우 유사하지만. 다른점이 있다면 React의 생명주기 메소드인 shouldComponentUpdate 를 다루는 방식에 있다.   
Component의 경우 setState가 실행되는 모든 순간에 Component가 Re-Rendering이 발생하지만, PureComponent의 경우에는 setState에서 Value가   
실제로 변경될 때만 Re-Rendering이 일어나게 된다. 

```javascript

import React , { PureComponet } from 'react';

Class HelloWorld extend PureComponent {
  constructor(props){
    super(props);
    this.state = {
      value : 0
    }

    this.call_event = this.call_event.bind(this);
  }

  call_event() {=
    if(특정 조건){
      this.setState({
        counter: this.state .value + 변경값,
      });
    }else {
      this.setState({
        counter: this.state.value
      });
    }
  }

  render(){
    return (
      <div>
       {this.state.value}
        <br>
        <input
          type="button"
          onClick={this.call_event}
          value="click"
        />
      </div>
    )
  }
}


```

#### Portal component

React 버전 16부터 도입된 방법으로써, 컴포넌트를 렌더링할 때, UI를 어디에 렌더링 시킬지 DOM을 선택하여 부모 컴포넌트의 바깥에 렌더링할 수 있게 
해주는 기능입니다. 기존의 리액트에서는 컴포넌트를 렌더링 하게 될 때, 하위 컴포넌트들은 부모 컴포넌트의 DOM 내부에서 동작했어야 했지만, Portals를 사용하면
DOM의 계층 구조 시스템에 종속되지 않으면서 컴포넌트를 렌더링 할 수 있습니다. 

```javascript 

import ReactDOM from 'react-dom';

const ModalPortal = ({ children }) => {
  const el = document.getElementById('modal');
  return ReactDOM.createPortal(children, el);
};

export default ModalPortal;

```

```html 
                            
<body>
    You need to enable JavaScript to run this app.
    </noscript>
  <div id="root"><div>
  <div id="modal"><div>
<body>

```

우리가 해당 컴포넌트 방식을 사용하게 되면 우리가 원하는 컴포넌트의 결과를 DOM의 특정 엘리먼트에 렌더링 할 수 있게 됩니다. 

#### Functional Component

함수형 컴포넌트라고 부르며, 16.8전가지는 함수형 컴포넌트와 클래스 기반 컴포넌트의 성능 차이는 거의 드러나지 않았습니다. 
하지만 16.8에서 hooks가 도입되면서 함수형 컴포넌트에서 성능 최적화(useMemo, useCallback 등)를 진행할 수 있고, 라이프사이클(useEffect)를 
제어할 수 있어 성능적으로 함수형 컴포넌트가 우위에 있다고 할 수 있습니다. 

- 함수형 컴포넌트와 React Hook 

  - useState
  - useEffect
  - useContext
  - useReducer
  - useCallback
  - useMemo
  - useRef
  - useImperativeHandle
  - useLayoutEffect
  - useDebugValue

#### Presentaitional Component

  Presentaitional Component는 데이터와 관련된 이벤트 혹은 State 관리 없이 사용자에게 보여지는 뷰만을 관리합니다. DOM Element, style 등이 들어가며
ReadOnly Component라고도 부를 수 있습니다. 또한, 대부분의 경우 state를 갖고 있지 않으며, 갖고 있을 경우엔 데이터와 관련된 것이아니라 UI와 관련된것이어야 합니다. 

#### Container Component

여러 컴포넌트를 관리하기 위해서 작성되며, DOM Elements를 직접적으로 수정하거나 관리하지 않습니다. 